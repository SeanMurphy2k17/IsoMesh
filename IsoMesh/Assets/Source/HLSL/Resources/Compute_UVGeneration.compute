#pragma kernel GenerateUVs
#pragma kernel GenerateUVsVoxelBased
#pragma kernel GenerateUVsLocalSpace
#pragma kernel GenerateUVsTriplanar
#pragma kernel GenerateUVsSpherical
#pragma kernel GenerateUVsTBN
#pragma kernel AnalyzeVertexProjections
#pragma kernel CountDuplicatesNeeded
#pragma kernel GenerateOriginalVertexUVs
#pragma kernel CreateDuplicateVertices
#pragma kernel RemapTriangleIndices
#pragma kernel FinalizeTriplanarUVs

// Input: Generated mesh data
StructuredBuffer<float3> _MeshVertices;
StructuredBuffer<float3> _MeshNormals;
StructuredBuffer<int> _MeshTriangles; // For analyzing connectivity

// Output: Generated UVs
RWStructuredBuffer<float2> _GeneratedUVs;

// For vertex duplication at UV seams - Multi-pass buffers
RWStructuredBuffer<int> _VertexProjectionMask;    // Bit flags showing which projections each vertex needs
RWStructuredBuffer<int> _VertexDuplicateCount;    // How many duplicates each vertex needs
RWStructuredBuffer<int> _VertexDuplicateOffset;   // Offset into duplicate arrays for each vertex
RWStructuredBuffer<int> _TotalDuplicatesCounter;  // Single value: total duplicates needed

// Duplicate vertex data - Packed to reduce UAV count
struct DuplicateVertexData {
    float3 vertex;
    float3 normal;
    float2 uv;
    int sourceIndex;
    int projection;
};

RWStructuredBuffer<DuplicateVertexData> _DuplicateVertexData; // All duplicate vertex data in one buffer

// Triangle remapping
RWStructuredBuffer<int> _RemappedTriangles;       // Updated triangle indices using duplicates

// Settings
float _UVScale;
float3 _BoundsMin;
float3 _BoundsMax;
float4x4 _MeshTransform; // For local space calculations
float _CellSize; // For voxel-based UVs
int _PointsPerSide; // For voxel-based UVs
uint _VertexCount;
uint _TriangleCount;
int _DebugMode; // 0 = normal, 1 = face selection debug, 2 = UV coordinate debug
float _BlendSharpness; // Controls triplanar blend sharpness (1=smooth, 8=sharp)  

// KERNEL 1: Basic UV Generation (World Space)
[numthreads(64,1,1)]
void GenerateUVs (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
        
    float3 vertex = _MeshVertices[id.x];
    float3 normal = _MeshNormals[id.x];
    
    // Simple planar XZ projection
    float2 uv = vertex.xz / _UVScale;
    
    _GeneratedUVs[id.x] = uv;
}

// KERNEL 2: Voxel-Based UV Generation (Our Genius Method!)
[numthreads(64,1,1)]
void GenerateUVsVoxelBased (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
        
    float3 vertex = _MeshVertices[id.x];
    
    // Convert to voxel grid coordinates
    float gridBounds = ((float)_PointsPerSide - 1.0) * _CellSize * 0.5;
    float3 normalizedGridPos = (vertex + gridBounds) / (gridBounds * 2.0);
    
    // Use XZ plane of voxel grid as UV
    float2 uv = normalizedGridPos.xz;
    
    _GeneratedUVs[id.x] = uv;
}

// KERNEL 3: Local Space UV Generation (Object-Relative)
[numthreads(64,1,1)]
void GenerateUVsLocalSpace (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
        
    float3 worldVertex = _MeshVertices[id.x];
    float3 normal = _MeshNormals[id.x];
    
    // Convert to local space using inverse transform
    float3x3 rotationOnly = (float3x3)_MeshTransform;
    float3 localVertex = mul(transpose(rotationOnly), worldVertex);
    
    // Generate UVs in local space
    float2 uv = (localVertex.xz + 5.0) / 10.0; // Assuming Â±5 unit bounds
    
    _GeneratedUVs[id.x] = uv;
}

// KERNEL 4: Triplanar UV Generation (THE BEAUTIFUL ONE!)
[numthreads(64,1,1)]
void GenerateUVsTriplanar (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
        
    // Vertices are already in mesh local space from the generation pass
    float3 localVertex = _MeshVertices[id.x];
    float3 localNormal = normalize(_MeshNormals[id.x]);
    
    // Calculate triplanar UVs from all 3 projections (using local space)
    // Add small offset to break alignment with volume bounds
    float3 uvOffset = float3(0.137, 0.251, 0.419); // Prime numbers to avoid patterns
    float3 offsetVertex = localVertex + uvOffset;
    
    // Fixed UV projections with correct orientations
    float2 uvX = float2(-offsetVertex.z, offsetVertex.y) / _UVScale;  // X-axis projection (left/right faces) - fixed rotation!
    float2 uvY = offsetVertex.xz / _UVScale;  // Y-axis projection (top/bottom faces)  
    float2 uvZ = offsetVertex.xy / _UVScale;  // Z-axis projection (front/back faces)
    
    // Calculate blend weights based on LOCAL normal (not world normal!)
    float3 blendWeights = abs(localNormal);
    
    // Adjust blend sharpness (lower = smoother transitions, higher = sharper)
    // Controlled by _BlendSharpness parameter (1.0 to 8.0)
    blendWeights = pow(blendWeights, _BlendSharpness);
    
    // Normalize weights
    blendWeights = blendWeights / (blendWeights.x + blendWeights.y + blendWeights.z);
    
        // Proper triplanar UV blending - no more hard projection switches!
    // This eliminates seams by smoothly blending UV coordinates from all 3 projections
    float2 finalUV = uvX * blendWeights.x + uvY * blendWeights.y + uvZ * blendWeights.z;
      
    // Output the actual blended UVs (not debug blend weights!)
    _GeneratedUVs[id.x] = finalUV;
  
}

// KERNEL 5: Spherical UV Generation (No Seams!)
[numthreads(64,1,1)]
void GenerateUVsSpherical (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
        
    // Vertices are already in mesh local space
    float3 localVertex = _MeshVertices[id.x];
    float3 localNormal = normalize(_MeshNormals[id.x]);
    
    // Convert to spherical coordinates
    float3 normalized = normalize(localVertex);
    
    // Calculate spherical angles
    float theta = atan2(normalized.z, normalized.x); // Azimuth angle (-PI to PI)
    float phi = asin(normalized.y); // Elevation angle (-PI/2 to PI/2)
    
    // Convert to UV coordinates (0 to 1)
    float u = (theta + 3.14159265359) / (2.0 * 3.14159265359);
    float v = (phi + 1.57079632679) / 3.14159265359;
    
    _GeneratedUVs[id.x] = float2(u, v) * _UVScale;
}

// KERNEL 6: TBN (Tangent-Bitangent-Normal) UV Generation - SDF-derived local frames
[numthreads(64,1,1)]
void GenerateUVsTBN (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
        
    float3 localVertex = _MeshVertices[id.x];
    float3 normal = normalize(_MeshNormals[id.x]);
    
    // Create a local tangent space from the normal
    // We need to find two perpendicular vectors to the normal
    
    // Choose a tangent direction based on the smallest component of the normal
    // This ensures we don't pick a direction parallel to the normal
    float3 tangent;
    float3 up = abs(normal.y) < 0.999 ? float3(0, 1, 0) : float3(1, 0, 0);
    tangent = normalize(cross(normal, up));
    
    // Calculate bitangent as cross product
    float3 bitangent = normalize(cross(normal, tangent));
    
    // Recalculate tangent to ensure orthonormal basis
    tangent = normalize(cross(bitangent, normal));
    
    // Project vertex position onto the tangent plane
    // This gives us UV coordinates that follow the surface
    float u = dot(localVertex, tangent);
    float v = dot(localVertex, bitangent);
    
    // Scale and offset to get nice UV range
    _GeneratedUVs[id.x] = float2(u, v) / _UVScale;
}

// Helper functions for UV seam detection
int GetTriangleUVProjection(float3 normal) {
    float3 absNormal = abs(normal);
    
    if (absNormal.x > absNormal.y && absNormal.x > absNormal.z)
        return 0; // X-axis projection (YZ plane)
    else if (absNormal.y > absNormal.z)
        return 1; // Y-axis projection (XZ plane)
    else
        return 2; // Z-axis projection (XY plane)
}

float2 CalculateUVForProjection(float3 vertex, int projectionType) {
    float3 uvOffset = float3(0.137, 0.251, 0.419);
    float3 offsetVertex = vertex + uvOffset;
    
    switch(projectionType) {
        case 0: // X-axis projection
            return float2(-offsetVertex.z, offsetVertex.y) / _UVScale;
        case 1: // Y-axis projection
            return offsetVertex.xz / _UVScale;
        case 2: // Z-axis projection
            return offsetVertex.xy / _UVScale;
        default:
            return float2(0, 0);
    }
}

// PASS 1: Analyze which projections each vertex needs
[numthreads(64,1,1)]
void AnalyzeVertexProjections (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TriangleCount)
        return;
    
    // Get triangle indices
    int i0 = _MeshTriangles[id.x * 3 + 0];
    int i1 = _MeshTriangles[id.x * 3 + 1];
    int i2 = _MeshTriangles[id.x * 3 + 2];
    
    // Get triangle vertices and calculate normal
    float3 v0 = _MeshVertices[i0];
    float3 v1 = _MeshVertices[i1];
    float3 v2 = _MeshVertices[i2];
    
    float3 triangleNormal = normalize(cross(v1 - v0, v2 - v0));
    int projection = GetTriangleUVProjection(triangleNormal);
    
    // Mark that these vertices need this projection
    // Use atomic OR to set the bit for this projection
    InterlockedOr(_VertexProjectionMask[i0], 1 << projection);
    InterlockedOr(_VertexProjectionMask[i1], 1 << projection);
    InterlockedOr(_VertexProjectionMask[i2], 1 << projection);
}

// PASS 2: Count how many duplicates each vertex needs
[numthreads(64,1,1)]
void CountDuplicatesNeeded (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
    
    int mask = _VertexProjectionMask[id.x];
    int projectionCount = 0;
    
    // Count bits set in mask (how many different projections this vertex needs)
    projectionCount += (mask & 1) ? 1 : 0;        // X projection
    projectionCount += (mask & 2) ? 1 : 0;        // Y projection
    projectionCount += (mask & 4) ? 1 : 0;        // Z projection
    
    // Each vertex needs (projectionCount - 1) duplicates
    // The original vertex will handle one projection, duplicates handle the rest
    int duplicatesNeeded = max(0, projectionCount - 1);
    _VertexDuplicateCount[id.x] = duplicatesNeeded;
    
    if (duplicatesNeeded > 0) {
        // Atomically add to total counter and store offset
        int offset;
        InterlockedAdd(_TotalDuplicatesCounter[0], duplicatesNeeded, offset);
        _VertexDuplicateOffset[id.x] = offset;
    } else {
        _VertexDuplicateOffset[id.x] = -1; // No duplicates needed
    }
}

// PASS 3A: Generate UVs for original vertices
[numthreads(64,1,1)]
void GenerateOriginalVertexUVs (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
    
    int mask = _VertexProjectionMask[id.x];
    float3 vertex = _MeshVertices[id.x];
    
    // Determine which projection the original vertex will use (first one found)
    int originalProjection = -1;
    for (int firstProj = 0; firstProj < 3; firstProj++) {
        if (mask & (1 << firstProj)) {
            originalProjection = firstProj;
            break;
        }
    }
    
    // Calculate UV for original vertex
    _GeneratedUVs[id.x] = CalculateUVForProjection(vertex, originalProjection);
}

// PASS 3B: Create the actual duplicate vertices
[numthreads(64,1,1)]
void CreateDuplicateVertices (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _VertexCount)
        return;
    
    int duplicatesNeeded = _VertexDuplicateCount[id.x];
    if (duplicatesNeeded == 0)
        return;
    
    int mask = _VertexProjectionMask[id.x];
    int offset = _VertexDuplicateOffset[id.x];
    
    float3 vertex = _MeshVertices[id.x];
    float3 normal = _MeshNormals[id.x];
    
    // Determine which projection the original vertex will use (first one found)
    int originalProjection = -1;
    for (int firstProj = 0; firstProj < 3; firstProj++) {
        if (mask & (1 << firstProj)) {
            originalProjection = firstProj;
            break;
        }
    }
    
    // Create duplicates for other projections
    int duplicateIndex = 0;
    for (int proj = 0; proj < 3; proj++) {
        if ((mask & (1 << proj)) && proj != originalProjection) {
            int globalDuplicateIndex = offset + duplicateIndex;
            
            DuplicateVertexData dupData;
            dupData.vertex = vertex;
            dupData.normal = normal;
            dupData.uv = CalculateUVForProjection(vertex, proj);
            dupData.sourceIndex = id.x;
            dupData.projection = proj;
            _DuplicateVertexData[globalDuplicateIndex] = dupData;
            
            duplicateIndex++;
        }
    }
}

// PASS 4: Remap triangle indices to use appropriate vertices
[numthreads(64,1,1)]
void RemapTriangleIndices (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _TriangleCount)
        return;
    
    // Get original triangle indices
    int i0 = _MeshTriangles[id.x * 3 + 0];
    int i1 = _MeshTriangles[id.x * 3 + 1];
    int i2 = _MeshTriangles[id.x * 3 + 2];
    
    // Calculate triangle normal to determine projection
    float3 v0 = _MeshVertices[i0];
    float3 v1 = _MeshVertices[i1];
    float3 v2 = _MeshVertices[i2];
    
    float3 triangleNormal = normalize(cross(v1 - v0, v2 - v0));
    int triangleProjection = GetTriangleUVProjection(triangleNormal);
    
    // For each vertex, find the appropriate version (original or duplicate)
    int remapped[3];
    remapped[0] = i0;
    remapped[1] = i1;
    remapped[2] = i2;
    
    for (int v = 0; v < 3; v++) {
        int originalVertex = _MeshTriangles[id.x * 3 + v];
        int mask = _VertexProjectionMask[originalVertex];
        
        // Check if this vertex has the projection we need
        if (mask & (1 << triangleProjection)) {
            // Find which projection the original vertex uses
            int originalProjection = -1;
            for (int proj = 0; proj < 3; proj++) {
                if (mask & (1 << proj)) {
                    originalProjection = proj;
                    break;
                }
            }
            
            // If original vertex doesn't use our projection, find the duplicate that does
            if (originalProjection != triangleProjection) {
                int offset = _VertexDuplicateOffset[originalVertex];
                int duplicatesNeeded = _VertexDuplicateCount[originalVertex];
                
                // Search through duplicates for the one with our projection
                for (int d = 0; d < duplicatesNeeded; d++) {
                    int duplicateIdx = offset + d;
                    if (_DuplicateVertexData[duplicateIdx].projection == triangleProjection) {
                        // Use this duplicate's index (offset by original vertex count)
                        remapped[v] = _VertexCount + duplicateIdx;
                        break;
                    }
                }
            }
        }
    }
    
    // Write remapped indices
    _RemappedTriangles[id.x * 3 + 0] = remapped[0];
    _RemappedTriangles[id.x * 3 + 1] = remapped[1];
    _RemappedTriangles[id.x * 3 + 2] = remapped[2];
}

// PASS 5: Finalize UVs for all vertices (including duplicates)
[numthreads(64,1,1)]
void FinalizeTriplanarUVs (uint3 id : SV_DispatchThreadID)
{
    uint totalVertices = _VertexCount + _TotalDuplicatesCounter[0];
    if (id.x >= totalVertices)
        return;
    
    // UVs for original vertices are already set in CreateDuplicateVertices
    // This kernel can be used for any final UV adjustments if needed
}
